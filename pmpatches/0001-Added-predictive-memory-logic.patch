From 2eb297f66e58a601bda64eaaeb7f24056a0851cf Mon Sep 17 00:00:00 2001
From: Bharath <linux.bhar@gmail.com>
Date: Thu, 4 Jul 2019 05:27:21 -0600
Subject: [PATCH 1/6] Added predictive memory logic

---
 include/linux/lsq.h | 16 +++++++++
 mm/lsq.c            | 99 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 115 insertions(+)
 create mode 100644 include/linux/lsq.h
 create mode 100644 mm/lsq.c

diff --git a/include/linux/lsq.h b/include/linux/lsq.h
new file mode 100644
index 0000000..8713cb0
--- /dev/null
+++ b/include/linux/lsq.h
@@ -0,0 +1,16 @@
+#ifndef LSQ_H
+#define LSQ_H
+
+#define COUNT 8
+
+struct lsq_struct {
+	int slot;
+	int ready;
+	long long y[COUNT];
+	long long sum_xy;
+	long long sum_y;
+};
+
+extern int predict(unsigned long *frag_vec, struct lsq_struct *lsq);
+
+#endif
diff --git a/mm/lsq.c b/mm/lsq.c
new file mode 100644
index 0000000..6756a32
--- /dev/null
+++ b/mm/lsq.c
@@ -0,0 +1,99 @@
+/*
+ * Least squares implementation
+ */
+
+#include <linux/lsq.h>
+#include <linux/mmzone.h>
+
+unsigned long R_c = 2500;
+unsigned long threshold = 0;
+
+long long SUM_X = ((COUNT * (1 - COUNT)) / 2);
+long long SUM_XX = ((COUNT * (COUNT - 1) * (2 * COUNT - 1)) / 6);
+
+static int
+lsq_fit(struct lsq_struct *lsq, unsigned long new_y, long long *m, long long *c)
+{
+	unsigned long long oldest_y;
+
+	oldest_y = lsq->y[lsq->slot];
+
+	lsq->sum_xy -= lsq->sum_y;
+	if (lsq->ready)
+		lsq->sum_xy += COUNT * oldest_y;
+
+	lsq->sum_y += new_y;
+	if (lsq->ready)
+		lsq->sum_y -= oldest_y;
+
+	lsq->y[lsq->slot++] = new_y;
+
+	if (lsq->slot == COUNT) {
+		lsq->slot = 0;
+		lsq->ready = 1;
+	}
+
+	if (!lsq->ready)
+		return -1;
+
+	*m = (COUNT * lsq->sum_xy - SUM_X * lsq->sum_y) /
+			(COUNT * SUM_XX - SUM_X * SUM_X);
+
+	*c = (lsq->sum_y - *m * SUM_X) / COUNT;
+
+	return 0;
+}
+
+int predict(unsigned long *frag_vec, struct lsq_struct *lsq)
+{
+	int order;
+	long long m[MAX_ORDER];
+	long long c[MAX_ORDER];
+	int is_ready = 1;
+	long long f_T_zero, R_T, f_f_zero, R_f, t_e, f_e;
+
+	for(order = 0; order < MAX_ORDER; order++) {
+		if (lsq_fit(&lsq[order], frag_vec[order], &m[order],
+				&c[order]) == -1)
+			is_ready = 0;
+	}
+
+	if (!is_ready)
+		return 0;
+
+	f_T_zero = c[0];
+	R_T = m[0];
+
+	for (order = 1; order < MAX_ORDER; order++) {
+		f_f_zero = c[order];
+		R_f = m[order];
+
+		if (f_T_zero <= f_f_zero)
+			continue;
+
+		if (R_T < R_f) {
+			t_e = (f_T_zero - f_f_zero) /
+					(R_f - R_T);
+			if (t_e < 1) {
+				f_e = (f_T_zero - f_f_zero) * R_T /
+						(R_f - R_T) + f_T_zero;
+
+				if (f_e > threshold)
+					return 1;
+			}
+		}
+
+		if (R_T < R_f + R_c) {
+			t_e = (f_T_zero - f_f_zero + R_c) /
+					(R_f + R_c - R_T);
+			if (t_e > 1) {
+				f_e = (f_T_zero - f_f_zero + R_c) * R_T /
+						(R_f + R_c - R_T) + f_T_zero;
+				if (f_e > threshold)
+					return 1;
+			}
+		}
+	}
+
+	return 0;
+}
-- 
1.8.3.1

